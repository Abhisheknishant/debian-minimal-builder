#!/usr/bin/env python3
#
# Read an initramdisk archive and simply list the files in it.
# Slightly more more useful than just "cpio -i -t" beacause libarchive
# takes care of uncompressing and we take care to show concatenated archives.
# 
# Assume LZMA compression

import os
import sys
import argparse
import libarchive

def argsparser():
    parser = argparse.ArgumentParser(
            description='Show the contents of an initramdisk')
    parser.add_argument('-i', '--input', required=True,
            type=argparse.FileType('rb', bufsize=4096),
            help='the input initramdisk archive')

    return parser.parse_args()

# really? there is no standard stream method for "currently at EOF" ?@?
def eof(file):
    return file.tell() == os.fstat(file.fileno()).st_size

def main():
    args = argsparser()

    while not eof(args.input):
        with libarchive.stream_reader(args.input) as archive:
            for entry in archive:
                print(entry.name)

        # FIXME:
        # - this is fragile!
        # - libarchive appears to read in blocks, but not reset the pointer

        # assuptions about the header:
        # - the lzma is always a stream, thus uncompressed_size is UINT64_MAX
        # - the dictionary size is 8Meg and all other options are default
        # these assuptions currently match what the lzma cmdline tool does

        # Seek backwards, then look forwards for a LZMA start block:
        # 5d 00 00 80 00 ff ff ff ff ff ff ff ff

        args.input.seek(-8192, 1)
        while not eof(args.input):
            ch = args.input.read(1)
            if ch != b'\x5d':
                continue

            head = args.input.read(12)
            if head != b'\x00\x00\x80\x00\xff\xff\xff\xff\xff\xff\xff\xff':
                continue

            args.input.seek(-13, 1)

            # ensure that the separate archives are visible, if you go looking
            print()
            break

if __name__ == '__main__':
    main()
